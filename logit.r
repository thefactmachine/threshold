rm(list=ls(all=TRUE))
library(plyr) #for The MapValues function
library(ggplot2) # ggplot2
library(RCurl) # getURL


#=======================================
# Data preparation section

x <- getURL("https://raw.githubusercontent.com/thefactmachine/logisticRegression/master/SAHeart.csv")
dfSA <- read.csv(text = x,  header = TRUE, sep = ",")

# dim(dfSA) == 462 * 11
#dfSA <- read.csv("SAHeart.csv")
dfSA$row.names <- NULL
# recode 0,1 as true / false
chdVector <- mapvalues(dfSA$chd, from = c(0,1), to = c("FALSE", "TRUE"))

dfSA$chd <- as.logical(chdVector)

# create vectors for k folds, where k = 5
numberOfFolds <- 5
set.seed(12)
# create a vector length(DataFrame) consisting of elements from 1:k
# so has something like: 1 5 5 2 1 1 1 4 1 1 2 5 2  and length = 462
kFolds <- sample(1:numberOfFolds, nrow(dfSA), replace = TRUE)

# create blank lists:
# lstProbs contains probabilities generated by model applied to test data
lstProbs <- list()
# lstTestData contains T or F actual values of the test data
lstTestData <- list()

# fold names will be the list elements "fold1"...'foldk'
# "fold1" "fold2" "fold3" "fold4" "fold5"
foldNames <- paste("fold", 1:numberOfFolds, sep="")

# set up single column matrix of probabilities
# create a vector 0.01 to 0.99 (99 elements)
# length = 99
threshSeq <- seq(from = 0.01, to = 0.99, by = 0.01)

# create the 99 x 1 matrix
matProb <- matrix(threshSeq, nrow = length(threshSeq))

# assign colname and then rownames to the matrix
colnames(matProb) <- "prob"; rownames(matProb) <- seq(1:length(threshSeq))

#=======================================
# Modelling section

# create k different models and then create predictions based on test sets
for (k in 1:numberOfFolds) {
  # iterate through the numberOfFolds. 5 folds in this case.
  # fit logit regression using all predictor variables 'chd' is dependent variable
  # fitted model uses training data. i.e. [kFolds != k,] 
  
  # fit a model
  fittedModel <- glm(chd ~., data=dfSA[kFolds != k,], family=binomial)
  # predict function uses fitted model to predict probabilites.
  # this uses test data: [kFolds == k,]
  predProbs <- predict(fittedModel, newdata=dfSA[kFolds == k,], type = "response")
  
  # lstProbs contains 5 main element: 'fold1' ...'foldk' these folds will have a slightly different length
  lstProbs[[foldNames[k]]] <- predProbs
  
  lstTestData[[foldNames[k]]] <- dfSA[kFolds == k, "chd"]
  # assert sameDimenstions(lstTestData, lstTestData) == TRUE 
}

library(dplyr)
table(kFolds) 
# above is equal to 99 98 78 95 92 ..these sum to 462
table(kFolds) %>% sum() == nrow(dfSA)









#=======================================
# following are calculations for overall accuracy of the logit model

fnCalcAccuracy <- function(probability) {
  # this function is called by apply(). The function is called repeatedly.
  # each time the function is called a different probability is called.
  
  #lstProbs is converted to lstBlnPredict, based on the current probability
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  # following returns 1 x 5 vector  Result is run for each probability
  # This creates a 5 (fold) x 1 (probability) vector for each iteration 
  vectAccuracy <- mapply(function(x, y) {mean(x == y)}, lstBlnPredict, lstTestData)
  # After the 99 iterations (5 x 1) vectors are assembled into a 5 x 99 matrix by apply()
}




# t(5 x 99) becomes (99 x 5) matrix
matAccuracy <- t(apply(matProb, 1, fnCalcAccuracy))

rownames(matAccuracy) <- threshSeq

# vctAccuracy = 1 x  99 vector
vctAccuracy <- apply(matAccuracy, 1, mean)

#=======================================
# following are calculations for Recall

# RECALL ==  True Positive / (True Positive + False Negative)
# PRECISION =  True Positive /  (True Positive + False Positive )



fnCalcRecall <- function(probability) {
  # this fuction operates exactly the same as fnCalcAccuracy except the mapply call..
  # ..has a different function. Two functions have could be refactored into a single..
  # ..function with a function as an argument.
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  vectRecall <- mapply(function(pred, actual){ sum(pred & actual) / sum(actual) }, 
                       lstBlnPredict, lstTestData )
}

# here we get a matrix with fold1...fold5 as columns.
matRecall <- t(apply(matProb, 1, fnCalcRecall))

rownames(matRecall) <- threshSeq
vctRecall <- apply(matRecall, 1, mean)



#=======================================
# following are calculations for Precision

fnCalcPrecision <- function(probability) {
  # returns a fold1 ... fold 5 list of booleans. These are the predictions given a specific probability
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  # following returns 1 x 5 vector  Result is run for each probability
  # This creates |probability| x nFold matrix
  
  # lstBlnPredict = pred; lstTestData = actual
  vectPrecision <- mapply(function(pred, actual){ sum(pred & actual) / sum(pred) }, 
                       lstBlnPredict, lstTestData )
}


matPrecision <- t(apply(matProb, 1, fnCalcPrecision))
rownames(matPrecision) <- threshSeq
vctPrecision <- apply(matPrecision, 1, mean)

#set NaN's to 1..bit of hack here. NaN's result of divide by zero error
vctPrecision <- ifelse(is.na(vctPrecision), 1, vctPrecision)

# We have a confusion matrix with Rows = Actual; Columns = Prediction
# true negative (1, 1)
# false negative (2, 1)
# false positive (1, 2)
# true positive (2,2)

# ================= true negatives ==================
fn_calc_true_negative <- function(probability) {
  # calculate applied test score given the threshold
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  
  # get vector of  counts
  vct_count_tn <- mapply(function(pred, actual){ sum(!pred & !actual) }, 
                         lstBlnPredict, lstTestData )
  # return vector of probabilities given number test cases per fold
  return (vct_count_tn / sapply(lstTestData, length))
}

mat_tn <- t(apply(matProb, 1, fn_calc_true_negative))
rownames(mat_tn) <- threshSeq
vct_tn <- apply(mat_tn, 1, mean)

# ================= false negatives ==================

fn_calc_false_negative <- function(probability) {
  # calculate applied test score given the threshold
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  
  # get vector of  counts
  vct_count_fn <- mapply(function(pred, actual){ sum(!pred & actual) }, 
                         lstBlnPredict, lstTestData )
  # return vector of probabilities given number test cases per fold
  return (vct_count_fn / sapply(lstTestData, length))
}

mat_fn <- t(apply(matProb, 1, fn_calc_false_negative))
rownames(mat_fn) <- threshSeq
vct_fn <- apply(mat_fn, 1, mean)

# ================= false positive ==================

fn_calc_false_postive <- function(probability) {
  # calculate applied test score given the threshold
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  
  # get vector of  counts
  vct_count_fp <- mapply(function(pred, actual){ sum(pred & !actual)  }, 
                         lstBlnPredict, lstTestData )
  # return vector of probabilities given number test cases per fold
  return (vct_count_fp / sapply(lstTestData, length))
}

mat_fp <- t(apply(matProb, 1, fn_calc_false_postive))
rownames(mat_fp) <- threshSeq
vct_fp <- apply(mat_fp, 1, mean)

# ================= true positive ==================

fn_calc_true_postive <- function(probability) {
  # calculate applied test score given the threshold
  lstBlnPredict <- lapply(lstProbs, function(x) ifelse(x > probability, T, F))
  
  # get vector of  counts
  vct_count_tp <- mapply(function(pred, actual){ sum(pred & actual)   }, 
                         lstBlnPredict, lstTestData )
  # return vector of probabilities given number test cases per fold
  return (vct_count_tp / sapply(lstTestData, length))
}

mat_tp <- t(apply(matProb, 1, fn_calc_true_postive))
rownames(mat_tp) <- threshSeq
vct_tp <- apply(mat_tp, 1, mean)
# ==================================================
# ==================================================
# ==================================================


# Assemble accuracy, recall & precision into a dataframe
dfThold <- data.frame(tHold = threshSeq, accuracy = vctAccuracy, 
                      recall = vctRecall, precision = vctPrecision, 
                      tn = vct_tn, fn = vct_fn, fp = vct_fp, tp =vct_tp )

# check check check check 

# check all 1's
dfThold[,5] + dfThold[,6] + dfThold[,7] + dfThold[,8] 

# RECALL:  true positive + false negative
vct_calc_denom_recall <- dfThold[, c("tp")] + dfThold[, c("fn")] 
vct_calc_denom_recall <- ifelse(vct_calc_denom_recall == 0, NA, vct_calc_denom_recall)
vct_calc_recal <- dfThold[, c("tp")]  / vct_calc_denom_recall
# add it to the data frame....
dfThold$c_recal <- vct_calc_recal

# Precision:  true positive + false positive
vct_calc_denom_precision <- dfThold[, c("tp")] + dfThold[, c("fp")] 
vct_calc_denom_precision <- ifelse(vct_calc_denom_precision == 0, NA, vct_calc_denom_precision)
vct_calc_precision <- dfThold[, c("tp")]  / vct_calc_denom_precision

vct_calc_precision <- ifelse(is.na(vct_calc_precision), 1, vct_calc_precision)
dfThold$c_precis <- vct_calc_precision

# I think these last two rows are better calculations for precision and recall.....


#=======================================
# GGPlot2 Section

lineSize = 1
plot <- ggplot(dfThold, aes(tHold)) 
plot <- plot + geom_line(aes(y = accuracy), colour = '#FF0000', size = lineSize /2)
plot <- plot + geom_line(aes(y = recall), colour = '#00CC00', size = lineSize)
plot <- plot + geom_line(aes(y = precision), colour = '#0000CC', size = lineSize)
plot <- plot + coord_fixed()
plot




# Can (un)comment the following to save the graph to file
# ggsave(file = "precisionRecallA.pdf",  useDingbats=FALSE)

#=======================================
# Create two tables for T = 0.50 and T = 0.25



# Creates list with 5 logical vectors

lstBlnPredict050 <- lapply(lstProbs, function(x) ifelse(x > 0.50, T, F))
print("table elements for threshold 0.50")
apply(mapply(table, lstBlnPredict050, lstTestData),1, sum)

lstBlnPredict025 <- lapply(lstProbs, function(x) ifelse(x > 0.25, T, F))
print("table elements for threshold 0.25")
apply(mapply(table, lstBlnPredict025, lstTestData),1, sum)